= Board Support Package
:toc:

:sectnums:

== CSR

These functions concern the CSR:

`uint64_t csr_get_cycle(void)`

* Get the current cycle count since last reset as a 64-bit unsigned number.

`uint64_t csr_get_instret(void)`

* Get the number of retired instructions since last reset as a 64-bit unsigned number.

`uint64_t csr_get_time(void)`

* Get the number of microseconds since last reset as a 64-bit unsigned number.

`uint64_t csr_get_mhpmcounter3(void)` +
`uint64_t csr_get_mhpmcounter4(void)` +
`uint64_t csr_get_mhpmcounter5(void)` +
`uint64_t csr_get_mhpmcounter6(void)` +
`uint64_t csr_get_mhpmcounter7(void)` +
`uint64_t csr_get_mhpmcounter8(void)` +
`uint64_t csr_get_mhpmcounter9(void)`

* Get the number of counter events since last reset as a 64-bit unsigned number. Note: Zihpm extenion must be enabled in the hardware.

These macros concern the CSR:

`csr_read(csr)`

* Returns the 32-bit unsigned contents of a CSR register.

`csr_write(csr, val)`

* Writes the unsigned 32-bits value in `val` to the given CSR register.

`csr_set(csr, val)`

* Set bits in named CSR register

`csr_clear(csr, val)`

* Clear bits in named CSR register


== GPIO

`uint32_t gpioa_readpin(uint32_t pin)`

* Get the state of an input pin. Please use one pin at a time. The result is either `GPIO_PIN_RESET` or `GPIO_PIN_SET`.


`void gpioa_writepin(uint32_t pin, uint32_t value)`

* Set the state of an output pin. More than one pin may be set in one call. The state is either `GPIO_PIN_RESET` or `GPIO_PIN_SET`.

`void gpioa_togglepin(uint32_t pin)`

* Toggle the state of a output pin. More than one pin may be toggled in one call.

Note: `pin` is a pin list. Each bit in the 32-bit `pin` represents one pin with the same index number.


== I2C

`void i2c1_init(uint32_t val)` +
`void i2c2_init(uint32_t val)`

* Initialize the I2C1/I2C2 peripherals. `val` is copied one-to-one to the CTRL register.

`uint8_t i2c1_receive_byte(void)` +
`uint8_t i2c2_receive_byte(void)`

* Receive one byte from the I2C1/I2C2 peripherals. These functions are blocking.

`uint32_t i2c1_receive(uint8_t address, uint8_t *buf, uint32_t len)` +
`uint32_t i2c2_receive(uint8_t address, uint8_t *buf, uint32_t len)`

* Receive `len` bytes from target with address `address` and store the bytes in the buffer pointed by `buf`. A return value of 0 indicates success. Includes START and STOP conditions.

`uint32_t i2c1_transmit_address(uint8_t address)` +
`uint32_t i2c2_transmit_address(uint8_t address)`

* Transmit an address on the I2C bus, including a START condition. A return value of 0 indicates success (target acknowledged).

`uint32_t i2c1_transmit_address_only(uint8_t address)` +
`uint32_t i2c2_transmit_address_only(uint8_t address)`

* Transmit an addess on the  I2C bus, including START and STOP conditions. Can be used to detect targets. A return value of 0 indicates success (target acknowledged).

`uint32_t i2c1_transmit_byte(uint8_t data)` +
`uint32_t i2c2_transmit_byte(uint8_t data)`

* Transmit one byte on the I2C1/I2C2 peripherals. A return value of 0 indicates success (target acknowledged). 

`int32_t i2c1_transmit(uint8_t address, uint8_t *buf, uint32_t len)` +
`int32_t i2c2_transmit(uint8_t address, uint8_t *buf, uint32_t len)`

* Transmit a buffer pointed by `buf` with length `len` to the target with address `address`, including START and STOP conditions.


== SPI

`void spi1_init(uint32_t value)` +
`void spi2_init(uint32_t value)`

* Initialize the SPI device. `value` is copied one-to-one to the CTRL register.

`void spi1_receive(uint8_t *buf, uint32_t len, uint32_t dummy)` +
`void spi2_receive(uint8_t *buf, uint32_t len, uint32_t dummy)`

* Receive `len` bytes of data and store them in a buffer pointed by `buf`, while sending bytes with value `dummy`.

`void spi1_transmit(uint8_t *buf, uint32_t len)` +
`void spi2_transmit(uint8_t *buf, uint32_t len)`

* Transmit `len` bytes of data pointed by `buf`, ignore received data.

`void spi1_transmit_receive(uint8_t *buft, uint8_t *bufr, uint32_t len)` +
`void spi2_transmit_receive(uint8_t *buft, uint8_t *bufr, uint32_t len)`

* Transmit and receive `len` bytes of data, `buft` for transmitting and `bufr` for receiving.

`uint32_t spi1_transfer(uint32_t data)` +
`uint32_t spi2_transfer(uint32_t data)`

* Transmit a datum `data`, which may be any supported size and return the received datum.

`__attribute__((weak)) void spi1_csenable(void)` +
`__attribute__((weak)) void spi2_csenable(void)`


* Weak placeholders for activating the Chip Select signals. The user must override these functions with own functions. These weak functions do nothing.

`__attribute__((weak)) void spi1_csdisable(void)` +
`__attribute__((weak)) void spi2_csdisable(void)`

* Weak placeholders for disabling the Chip Select signals. The user must override these functions with own functions. These weak functions do nothing.


== TIMER1

`void inline timer1_enable(void)`

* Enable TIMER1.

`void inline timer1_disable(void)`

* Disable TIMER1.

`uint32_t inline timer1_getcounter(void)`

* Get the current TIMER1 counter value as a unsigned 32-bit number.

`void inline timer1_setcounter(uint32_t cntr)`

* Set the TIMER1 counter value to the unsigned 32-bit number `cntr`.

`void inline timer1_setcompare(uint32_t cmpt)`

* Set TIMER1 compare T register (CMPT) to the unsigned 32-bit number `cmpt`.

`void inline timer1_enable_interrupt(void)`

* Enable TIMER1 interrupt.

`void inline timer1_disable_interrupt(void)`

* Disable TIMER1 interrupt.

`void inline timer1_clear_interrupt(void)`

* Clear TIMER1 overflow flags, this clears a pending interrupt.


== UART

`void uart1_init(uint32_t baudrate, uint32_t ctrl)`

* Initialize UART1. `baudrate` is the baud rate in bits per second. `ctrl` is copied to the CTRL register.

`void uart1_putc(int ch)`

* Write one character via UART1.

`void uart1_puts(char *s)`

* Write a null-terminated string via UART1.

`int uart1_getc(void)`

* Read one character via UART1.

`int uart1_gets(char buffer[], int size)`

* Read at most `size` minus 1 characters from UART1 into `buffer`, and null-terminate buffer. Returns characters received. Simple line-editing is supported: backspace and delete are supported. Return/enter terminates reading characters. Return/enter is not part of the returned buffer.

`int uart1_printf(const char *format, ...)`

* Print formatted string via UART1, at most 255 characters. Parameters are the same as `printf`. Returns the number of printed characters. Note: to print floating point numbers, supply the linker with `-u _printf_float`. Note: `long long` integers (a.k.a 64-bit) are not supported due to lack of the `nano` library.

`void uart1_printlonglong(int64_t v)`

* Print a signed long long integer (a.k.a. `int64_t`) via UART1.

`void uart1_printulonglong(uint64_t v)`

* Print an unsigned long long integer (a.k.a. `uint64_t`) via UART1.

`int uart1_hasreceived(void)`

* Returns != 0 if a character has been received via UART1.


== Watchdog (WDT)

`void wdt_init(uint32_t val)`

* Initialize the watchdog. `val` is copied to the CTRL register.

`void wdt_reset(void)`

* Resets the watchdog.

`void wdt_start(void)`

* Start the watchdog.

`void wdt_stop(void)`

* Stops the watchdog.



More to be added.

