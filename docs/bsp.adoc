= Board Support Package
:toc:

:sectnums:

== CSR

These functions concern the CSR:

`uint64_t csr_get_cycle(void)`

* Get the current cycle count since last reset as a 64-bit unsigned number.

`uint64_t csr_get_instret(void)`

* Get the number of retired instructions since last reset as a 64-bit unsigned number.

`uint64_t csr_get_time(void)`

* Get the number of microseconds since last reset as a 64-bit unsigned number.

`uint64_t csr_get_mhpmcounter3(void)` +
`uint64_t csr_get_mhpmcounter4(void)` +
`uint64_t csr_get_mhpmcounter5(void)` +
`uint64_t csr_get_mhpmcounter6(void)` +
`uint64_t csr_get_mhpmcounter7(void)` +
`uint64_t csr_get_mhpmcounter8(void)` +
`uint64_t csr_get_mhpmcounter9(void)`

* Get the number of counter events since last reset as a 64-bit unsigned number. Note: Zihpm extenion must be enabled in the hardware.

These macros concern the CSR:

`csr_read(csr)`

* Returns the 32-bit unsigned contents of a CSR register.

`csr_write(csr, val)`

* Writes the unsigned 32-bits value in `val` to the given CSR register.

`csr_set(csr, val)`

* Set bits in named CSR register

`csr_clear(csr, val)`

* Clear bits in named CSR register


== GPIO

`uint32_t gpioa_readpin(uint32_t pin)`

* Get the state of an input pin. Please use one pin at a time. The result is either `GPIO_PIN_RESET` or `GPIO_PIN_SET`.


`void gpioa_writepin(uint32_t pin, uint32_t value)`

* Set the state of an output pin. More than one pin may be set in one call. The state is ieither `GPIO_PIN_RESET` or `GPIO_PIN_SET`.

`void gpioa_togglepin(uint32_t pin)`

* Toggle the state of a output pin. More than one pin may be toggled in one call.

Note: `pin` is a pin list. Each bit in the 32-bit `pin` is one pin with the same index number.
`

== I2C

`void i2c1_init(uint32_t val)` +
`void i2c2_init(uint32_t val)`

* Initialize the I2C1/I2C2 peripherals.

`uint8_t i2c1_receive_byte(void)` +
`uint8_t i2c2_receive_byte(void)`

* Receive one byte from the I2C1/I2C2 peripherals. These functions are blocking.

`uint32_t i2c1_receive(uint8_t address, uint8_t *buf, uint32_t len)` +
`uint32_t i2c2_receive(uint8_t address, uint8_t *buf, uint32_t len)`

* Receive `len` bytes from target with address `address` and store the bytes in the buffer pointed by `buf`. A return value of 0 indicates success. Includes START and STOP conditions.

`uint32_t i2c1_transmit_address(uint8_t address)` +
`uint32_t i2c2_transmit_address(uint8_t address)`

* Transmit an address on the I2C bus, including a START condition. A return value of 0 indicates success (target acknowledged).

`uint32_t i2c1_transmit_address_only(uint8_t address)` +
`uint32_t i2c2_transmit_address_only(uint8_t address)`

* Transmit an addess on the  I2C bus, including START and STOP conditions. Can be used to detect targets. A return value of 0 indicates success (target acknowledged).

`uint32_t i2c1_transmit_byte(uint8_t data)` +
`uint32_t i2c2_transmit_byte(uint8_t data)`

* Transmit one byte on the I2C1/I2C2 peripherals. A return value of 0 indicates success (target acknowledged). 

`int32_t i2c1_transmit(uint8_t address, uint8_t *buf, uint32_t len)` +
`int32_t i2c2_transmit(uint8_t address, uint8_t *buf, uint32_t len)`

* Transmit a buffer pointed by `buf` with length `len` to the target with address `address`, including START and STOP conditions.


== SPI

`void spi1_init(uint32_t value)` +
`void spi2_init(uint32_t value)`

* Initialize the SPI device.

`void spi1_receive(uint8_t *buf, uint32_t len, uint32_t dummy)` +
`void spi2_receive(uint8_t *buf, uint32_t len, uint32_t dummy)`

* Receive `len` bytes of data and store them in a buffer pointed by `buf`, while sending bytes with value `dummy`.

`void spi1_transmit(uint8_t *buf, uint32_t len)` +
`void spi2_transmit(uint8_t *buf, uint32_t len)`

* Transmit `len` bytes of data pointed by `buf`, ignore received data.

`void spi1_transmit_receive(uint8_t *buft, uint8_t *bufr, uint32_t len)` +
`void spi2_transmit_receive(uint8_t *buft, uint8_t *bufr, uint32_t len)`

* Transmit and receive `len` bytes of data, `buft` for transmitting and `bufr` for receiving.

`uint32_t spi1_transfer(uint32_t data)` +
`uint32_t spi2_transfer(uint32_t data)`

* Transmit a datum `data`, which may be any supported size and return the received datum.

`__attribute__((weak)) void spi1_csenable(void)` +
`__attribute__((weak)) void spi2_csenable(void)`


* Weak placeholders for activating the Chip Select signals. The user must override these functions with own functions. These weak functions do nothing.

`__attribute__((weak)) void spi1_csdisable(void)` +
`__attribute__((weak)) void spi2_csdisable(void)`

* Weak placeholders for disabling the Chip Select signals. The user must override these functions with own functions. These weak functions do nothing.

More to be added.

