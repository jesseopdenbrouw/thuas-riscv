= Board Support Package
:toc:

:sectnums:

== CSR

These functions concern the CSR:

`uint64_t csr_get_cycle(void)`

* Get the current cycle count since last reset as a 64-bit unsigned number.

`uint64_t csr_get_instret(void)`

* Get the number of retired instructions since last reset as a 64-bit unsigned number.

`uint64_t csr_get_time(void)`

* Get the number of microseconds since last reset as a 64-bit unsigned number.

`uint64_t csr_get_mhpmcounter3(void)` +
`uint64_t csr_get_mhpmcounter4(void)` +
`uint64_t csr_get_mhpmcounter5(void)` +
`uint64_t csr_get_mhpmcounter6(void)` +
`uint64_t csr_get_mhpmcounter7(void)` +
`uint64_t csr_get_mhpmcounter8(void)` +
`uint64_t csr_get_mhpmcounter9(void)`

* Get the number of counter events since last reset as a 64-bit unsigned number. Note: Zihpm extenion must be enabled in the hardware.

These macros concern the CSR:

`csr_read(csr)`

* Returns the 32-bit unsigned contents of a CSR register.

`csr_write(csr, val)`

* Writes the 32-bits value in `val` to the given CSR register.

`csr_set(csr, val)`

* Set bits in named CSR register

`csr_clear(csr, val)`

* Clear bits in named CSR register


== GPIO

`uint32_t gpioa_readpin(uint32_t pin)`

* Get the state of an input pin. Please use one pin at a time. The result is either `GPIO_PIN_RESET` or `GPIO_PIN_SET`.


`void gpioa_writepin(uint32_t pin, uint32_t value)`

* Set the state of an output pin. More than one pin may be set in one call. The state is ieither `GPIO_PIN_RESET` or `GPIO_PIN_SET`.

`void gpioa_togglepin(uint32_t pin)`

* Toggle the state of a output pin. More than one pin may be toggled in one call.

== I2C

`void i2c1_init(uint32_t val)` +
`void i2c2_init(uint32_t val)`

* Initialize the I2C1/I2C2 peripherals.

`uint8_t i2c1_receive_byte(void)` +
`uint8_t i2c2_receive_byte(void)`

* Receive one byte from the I2C1/I2C2 peripherals. These functions are blocking.

`uint32_t i2c1_receive(uint8_t address, uint8_t *buf, uint32_t len)` +
`uint32_t i2c2_receive(uint8_t address, uint8_t *buf, uint32_t len)`

* Receive `len` bytes from target with address `address` and store the bytes in the buffer pointed by `buf`. A return value of 0 indicates success. Includes START and STOP conditions.

`uint32_t i2c1_transmit_address(uint8_t address)` +
`uint32_t i2c2_transmit_address(uint8_t address)`

* Transmit an address on the I2C bus, including a START condition. A return value of 0 indicates success (target acknowledged).

`uint32_t i2c1_transmit_address_only(uint8_t address)` +
`uint32_t i2c2_transmit_address_only(uint8_t address)`

* Transmit an addess on the  I2C bus, including START and STOP conditions. Can be used to detect targets. A return value of 0 indicates success (target acknowledged).

`uint32_t i2c1_transmit_byte(uint8_t data)` +
`uint32_t i2c2_transmit_byte(uint8_t data)`

* Transmit one byte on the I2C1/I2C2 peripherals. A return value of 0 indicates success (target acknowledged). 

`int32_t i2c1_transmit(uint8_t address, uint8_t *buf, uint32_t len)` +
`int32_t i2c2_transmit(uint8_t address, uint8_t *buf, uint32_t len)`

* Transmit a buffer pointed by `buf` with length `len` to the target with address `address`, including START and STOP conditions.



More to be added.

